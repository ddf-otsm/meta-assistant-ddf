
Executed cat > workflow_tasks/scripts/custom_branch_merge.sh << 'EOF' #!/bin/bash # Set up logging LOG_FILE="custom_branch_merge" LOG_DIR="./logs" # Define log functions and init_log_file if they don't exist init_log_file() { local log_name=$1 mkdir -p $LOG_DIR touch "$LOG_DIR/$log_name.log" echo "[$(date '+%Y-%m-%d %H:%M:%S')] Starting log for $log_name" >> "$LOG_DIR/$log_name.log" } log_info() { local message=$1 echo "[INFO] $message" echo "[$(date '+%Y-%m-%d %H:%M:%S')] [INFO] $message" >> "$LOG_DIR/$LOG_FILE.log" } log_warning() { local message=$1 echo "[WARNING] $message" echo "[$(date '+%Y-%m-%d %H:%M:%S')] [WARNING] $message" >> "$LOG_DIR/$LOG_FILE.log" } log_error() { local message=$1 echo "[ERROR] $message" echo "[$(date '+%Y-%m-%d %H:%M:%S')] [ERROR] $message" >> "$LOG_DIR/$LOG_FILE.log" } log_success() { local message=$1 echo "[SUCCESS] $message" echo "[$(date '+%Y-%m-%d %H:%M:%S')] [SUCCESS] $message" >> "$LOG_DIR/$LOG_FILE.log" } init_log_file $LOG_FILE # Process command line arguments DRY_RUN=false for arg in "$@"; do case $arg in --dry-run) DRY_RUN=true shift ;; esac done if [ "$DRY_RUN" = true ]; then log_info "===== STARTING CUSTOM BRANCH MERGE (DRY RUN MODE) =====" else log_info "===== STARTING CUSTOM BRANCH MERGE =====" fi # Check current branch CURRENT_BRANCH=$(git branch --show-current) log_info "Current branch: $CURRENT_BRANCH" # Ensure we're on the correct branch if [ "$CURRENT_BRANCH" != "agent-minion-replit-0-v1.1.0-merged-previous-versions-unknown" ]; then log_error "Not on the correct branch. Expected 'agent-minion-replit-0-v1.1.0-merged-previous-versions-unknown', got '$CURRENT_BRANCH'" exit 1 fi # Create a backup branch BACKUP_BRANCH="backup-pre-merge-$(date +%Y%m%d%H%M%S)" if [ "$DRY_RUN" = true ]; then log_info "[DRY RUN] Would create backup branch: $BACKUP_BRANCH" else log_info "Creating backup branch: $BACKUP_BRANCH" git branch $BACKUP_BRANCH $CURRENT_BRANCH if [ $? -ne 0 ]; then log_error "Failed to create backup branch" exit 1 else log_success "Created backup branch: $BACKUP_BRANCH" fi fi # Branches to merge in order BRANCHES_TO_MERGE=( "origin/v0.0.1-stable-front-back" "origin/v1.0.1-stable-front-back" "origin/v1.0.2-stable-front-back" "origin/agent-minion-replit-1-deploy-unknown" ) # Function to handle merge conflicts handle_merge_conflict() { local branch=$1 log_warning "Merge conflict detected with branch $branch" log_info "Options:" log_info "1. Resolve conflicts manually" log_info "2. Use 'ours' strategy (keep our changes in conflicts)" log_info "3. Use 'theirs' strategy (use their changes in conflicts)" read -p "Choose option (1/2/3): " option if [ "$option" = "2" ]; then log_info "Aborting merge to try with 'ours' strategy option" git merge --abort # Try with recursive strategy and ours option log_info "Retrying merge with recursive strategy and ours option" git merge -X ours $branch if [ $? -ne 0 ]; then log_error "Merge still failed with 'ours' strategy for branch $branch." log_info "Please resolve conflicts manually, then continue with: git add . && git commit -m 'Merge $branch'" exit 1 else log_success "Merge successful with 'ours' strategy for branch: $branch" git commit -m "Merge branch '$branch' into $CURRENT_BRANCH (ours strategy)" fi elif [ "$option" = "3" ]; then log_info "Aborting merge to try with 'theirs' strategy option" git merge --abort # Try with recursive strategy and theirs option log_info "Retrying merge with recursive strategy and theirs option" git merge -X theirs $branch if [ $? -ne 0 ]; then log_error "Merge still failed with 'theirs' strategy for branch $branch." log_info "Please resolve conflicts manually, then continue with: git add . && git commit -m 'Merge $branch'" exit 1 else log_success "Merge successful with 'theirs' strategy for branch: $branch" git commit -m "Merge branch '$branch' into $CURRENT_BRANCH (theirs strategy)" fi else log_info "Please resolve conflicts manually, then continue with: git add . && git commit -m 'Merge $branch'" exit 1 fi } # Process each branch for branch in "${BRANCHES_TO_MERGE[@]}"; do log_info "Processing branch: $branch" # Check if branch exists git show-ref --verify --quiet "refs/remotes/$branch" if [ $? -ne 0 ]; then log_warning "Branch $branch does not exist, skipping" continue fi if [ "$DRY_RUN" = true ]; then log_info "[DRY RUN] Would merge branch: $branch" # Check for potential merge conflicts git merge-tree $(git merge-base HEAD $branch) HEAD $branch | grep -i "^<<<<<<<" > /dev/null if [ $? -eq 0 ]; then log_warning "[DRY RUN] Potential merge conflicts detected with branch $branch" log_info "[DRY RUN] Would need to handle conflicts in real run" else log_info "[DRY RUN] No merge conflicts detected with branch $branch" log_info "[DRY RUN] Would perform standard merge in real run" fi else log_info "Merging branch: $branch" git merge --no-ff $branch -m "Merge branch '$branch' into $CURRENT_BRANCH" # Check if merge was successful if [ $? -ne 0 ]; then handle_merge_conflict $branch else log_success "Successfully merged branch: $branch" fi fi done # Verify all merges were successful if [ "$DRY_RUN" = false ]; then log_info "All branches have been merged successfully" log_info "The following branches were merged:" for branch in "${BRANCHES_TO_MERGE[@]}"; do log_info "- $branch" done fi # Final success message if [ "$DRY_RUN" = true ]; then log_info "===== CUSTOM BRANCH MERGE DRY RUN COMPLETED =====" else log_success "===== CUSTOM BRANCH MERGE COMPLETED SUCCESSFULLY =====" log_info "Now you can run the UI verification script to ensure everything is working properly" fi EOF chmod +x workflow_tasks/scripts/custom_branch_merge.sh
Now let's create a UI verification script to validate the UI after merging: