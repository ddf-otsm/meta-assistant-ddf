
Executed cat > workflow_tasks/scripts/rename_branches.sh << 'EOF' #!/bin/bash # Set up logging LOG_FILE="rename_branches" LOG_DIR="./logs" # Define log functions and init_log_file if they don't exist init_log_file() { local log_name=$1 mkdir -p $LOG_DIR touch "$LOG_DIR/$log_name.log" echo "[$(date '+%Y-%m-%d %H:%M:%S')] Starting log for $log_name" >> "$LOG_DIR/$log_name.log" } log_info() { local message=$1 echo "[INFO] $message" echo "[$(date '+%Y-%m-%d %H:%M:%S')] [INFO] $message" >> "$LOG_DIR/$LOG_FILE.log" } log_warning() { local message=$1 echo "[WARNING] $message" echo "[$(date '+%Y-%m-%d %H:%M:%S')] [WARNING] $message" >> "$LOG_DIR/$LOG_FILE.log" } log_error() { local message=$1 echo "[ERROR] $message" echo "[$(date '+%Y-%m-%d %H:%M:%S')] [ERROR] $message" >> "$LOG_DIR/$LOG_FILE.log" } log_success() { local message=$1 echo "[SUCCESS] $message" echo "[$(date '+%Y-%m-%d %H:%M:%S')] [SUCCESS] $message" >> "$LOG_DIR/$LOG_FILE.log" } init_log_file $LOG_FILE log_info "===== STARTING BRANCH RENAMING =====" # Process command line arguments DRY_RUN=false for arg in "$@"; do case $arg in --dry-run) DRY_RUN=true shift ;; esac done if [ "$DRY_RUN" = true ]; then log_info "Running in dry-run mode (no changes will be made)" fi # Branches to rename BRANCHES_TO_RENAME=( "origin/v0.0.1-stable-front-back:deprecated_v0.0.1-stable-front-back" "origin/v1.0.1-stable-front-back:deprecated_v1.0.1-stable-front-back" "origin/v1.0.2-stable-front-back:deprecated_v1.0.2-stable-front-back" "origin/agent-minion-replit-1-deploy-unknown:deprecated_agent-minion-replit-1-deploy-unknown" ) # Check if git credential helper is set up GIT_CREDENTIAL_HELPER=$(git config --global credential.helper) if [ -z "$GIT_CREDENTIAL_HELPER" ]; then log_warning "Git credential helper is not configured. Pushing renamed branches may require manual authentication" else log_info "Git credential helper is configured: $GIT_CREDENTIAL_HELPER" fi # Function to rename a branch rename_branch() { local old_branch=$1 local new_branch=$2 # Remove "origin/" prefix for the push ref local old_remote_ref=${old_branch#origin/} if [ "$DRY_RUN" = true ]; then log_info "[DRY RUN] Would rename $old_branch to $new_branch" else log_info "Renaming $old_branch to $new_branch" # Create new branch based on the old one git branch $new_branch $old_branch if [ $? -ne 0 ]; then log_error "Failed to create new branch $new_branch" return 1 fi # Push the new branch to remote git push origin $new_branch if [ $? -ne 0 ]; then log_error "Failed to push new branch $new_branch to remote" return 1 fi # Delete the old branch from remote (be careful with this!) log_warning "About to delete remote branch: $old_remote_ref" log_warning "Press Ctrl+C now to abort, or wait 5 seconds to continue..." sleep 5 git push origin --delete $old_remote_ref if [ $? -ne 0 ]; then log_error "Failed to delete old branch $old_remote_ref from remote" return 1 fi log_success "Successfully renamed $old_branch to $new_branch" fi return 0 } # Process each branch for branch_pair in "${BRANCHES_TO_RENAME[@]}"; do # Split old:new branch names OLD_BRANCH=$(echo $branch_pair | cut -d':' -f1) NEW_BRANCH=$(echo $branch_pair | cut -d':' -f2) # Check if old branch exists git show-ref --verify --quiet "refs/remotes/$OLD_BRANCH" if [ $? -ne 0 ]; then log_warning "Branch $OLD_BRANCH does not exist, skipping" continue fi # Check if new branch already exists git show-ref --verify --quiet "refs/heads/$NEW_BRANCH" if [ $? -eq 0 ]; then log_warning "Branch $NEW_BRANCH already exists, skipping" continue fi # Rename the branch rename_branch $OLD_BRANCH $NEW_BRANCH if [ $? -ne 0 ]; then log_error "Failed to rename branch $OLD_BRANCH to $NEW_BRANCH" if [ "$DRY_RUN" = false ]; then log_info "Continuing with the next branch..." fi fi done # Final success message if [ "$DRY_RUN" = true ]; then log_info "===== BRANCH RENAMING DRY RUN COMPLETED =====" else log_success "===== BRANCH RENAMING COMPLETED =====" fi EOF chmod +x workflow_tasks/scripts/rename_branches.sh
Now let's run the branch merge script in dry-run mode first to identify potential conflicts before doing the actual merge: